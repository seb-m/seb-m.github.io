var searchIndex = {};
searchIndex['crypto'] = {"items":[[0,"","crypto","Selection of crypto primitives in pure-Rust"],[0,"curve41417","","[Curve41417](http://safecurves.cr.yp.to/) elliptic curve"],[0,"bytes","crypto::curve41417","Raw bytes representations"],[6,"Bytes","crypto::curve41417::bytes","Raw bytes-representation."],[9,"new_zero","","Return a new element with all its bytes set to zero.",0],[9,"new_rand","","Return a new random element (use urandom as PRNG).",0],[9,"from_bytes","","Return a new instance from a byte slice.",0],[9,"len","","",0],[9,"as_bytes","","Return a reference on the internal bytes as a byte slice.",0],[9,"as_mut_bytes","","Return a mutable reference on the internal bytes as a mutable byte\nslice.",0],[9,"get","","Return a reference to the byte at index `index`. Fails if\n`index` is out of bounds.",0],[9,"get_mut","","Return a mutable reference to the byte at index `index`. Fails\nif `index` is out of bounds.",0],[10,"clamp_41417","curve41417::bytes","Clamp its bytes to set its value in `8.{1,2,3,...,2^410-1} + 2^413`.",1],[10,"unwrap","","Return the wrapped raw `SBuf` buffer value, consume `self`.",1],[10,"from_sbuf","","Consume `buf` and transform it in Bxxx.",1],[10,"len","","",1],[10,"new_zero","","Return a new instance initialized to zero.",1],[10,"new_rand","","Return a new randomly generated instance (use urandom as PRNG).",1],[10,"as_bytes","","Return a reference on the internal bytes as a byte slice.",1],[10,"as_mut_bytes","","Return a mutable reference on the internal bytes as a mutable byte\nslice.",1],[10,"from_bytes","","",1],[10,"get","","",1],[10,"get_mut","","",1],[10,"clone","","",1],[10,"clone_from","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"assert_receiver_is_total_eq","","",1],[10,"encode","","",1],[10,"decode","","",1],[10,"index","","",1],[10,"index_mut","","",1],[10,"from_str","","Convert from an hex-string.",1],[10,"fmt","","Format as hex-string.",1],[10,"rand","","Generate a new random instance. Be sure to use a secure\nPRNG when calling this method. For instance `Bytes::new_rand()`\nuses urandom.",1],[10,"to_hex","","",1],[10,"unwrap","","Return the wrapped raw `SBuf` buffer value, consume `self`.",2],[10,"from_sbuf","","Consume `buf` and transform it in Bxxx.",2],[10,"len","","",2],[10,"new_zero","","Return a new instance initialized to zero.",2],[10,"new_rand","","Return a new randomly generated instance (use urandom as PRNG).",2],[10,"as_bytes","","Return a reference on the internal bytes as a byte slice.",2],[10,"as_mut_bytes","","Return a mutable reference on the internal bytes as a mutable byte\nslice.",2],[10,"from_bytes","","",2],[10,"get","","",2],[10,"get_mut","","",2],[10,"clone","","",2],[10,"clone_from","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"assert_receiver_is_total_eq","","",2],[10,"encode","","",2],[10,"decode","","",2],[10,"index","","",2],[10,"index_mut","","",2],[10,"from_str","","Convert from an hex-string.",2],[10,"fmt","","Format as hex-string.",2],[10,"rand","","Generate a new random instance. Be sure to use a secure\nPRNG when calling this method. For instance `Bytes::new_rand()`\nuses urandom.",2],[10,"to_hex","","",2],[10,"unwrap","","Return the wrapped raw `SBuf` buffer value, consume `self`.",3],[10,"from_sbuf","","Consume `buf` and transform it in Bxxx.",3],[10,"len","","",3],[10,"new_zero","","Return a new instance initialized to zero.",3],[10,"new_rand","","Return a new randomly generated instance (use urandom as PRNG).",3],[10,"as_bytes","","Return a reference on the internal bytes as a byte slice.",3],[10,"as_mut_bytes","","Return a mutable reference on the internal bytes as a mutable byte\nslice.",3],[10,"from_bytes","","",3],[10,"get","","",3],[10,"get_mut","","",3],[10,"clone","","",3],[10,"clone_from","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"assert_receiver_is_total_eq","","",3],[10,"encode","","",3],[10,"decode","","",3],[10,"index","","",3],[10,"index_mut","","",3],[10,"from_str","","Convert from an hex-string.",3],[10,"fmt","","Format as hex-string.",3],[10,"rand","","Generate a new random instance. Be sure to use a secure\nPRNG when calling this method. For instance `Bytes::new_rand()`\nuses urandom.",3],[10,"to_hex","","",3],[10,"get","","Return the wrapped value as a reference.",4],[10,"get_byte","","Return a reference to the byte at index `index`. Fails if\n`index` is out of bounds.",4],[10,"unwrap","","Return the wrapped value, consume `self`.",4],[10,"clone","","",4],[10,"clone_from","","",4],[10,"eq","","",4],[10,"ne","","",4],[10,"assert_receiver_is_total_eq","","",4],[10,"fmt","","Format as hex-string.",4],[10,"encode","","",4],[10,"decode","","",4],[10,"index","","",4],[10,"to_hex","","",4],[10,"get","","Return the wrapped value as a reference.",5],[10,"get_byte","","Return a reference to the byte at index `index`. Fails if\n`index` is out of bounds.",5],[10,"unwrap","","Return the wrapped value, consume `self`.",5],[10,"clone","","",5],[10,"clone_from","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"assert_receiver_is_total_eq","","",5],[10,"fmt","","Format as hex-string.",5],[10,"encode","","",5],[10,"decode","","",5],[10,"index","","",5],[10,"to_hex","","",5],[10,"get","","Return the wrapped value as a reference.",6],[10,"get_byte","","Return a reference to the byte at index `index`. Fails if\n`index` is out of bounds.",6],[10,"unwrap","","Return the wrapped value, consume `self`.",6],[10,"clone","","",6],[10,"clone_from","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"assert_receiver_is_total_eq","","",6],[10,"fmt","","Format as hex-string.",6],[10,"encode","","",6],[10,"decode","","",6],[10,"index","","",6],[10,"to_hex","","",6],[10,"get","","Return the wrapped value as a reference.",7],[10,"get_byte","","Return a reference to the byte at index `index`. Fails if\n`index` is out of bounds.",7],[10,"unwrap","","Return the wrapped value, consume `self`.",7],[10,"clone","","",7],[10,"clone_from","","",7],[10,"eq","","",7],[10,"ne","","",7],[10,"assert_receiver_is_total_eq","","",7],[10,"fmt","","Format as hex-string.",7],[10,"encode","","",7],[10,"decode","","",7],[10,"index","","",7],[10,"to_hex","","",7],[10,"mul","","Multiply scalar with point.",4],[10,"mul","","Multiply point with scalar.",5],[10,"mul","","Multiply point with scalar.",6],[10,"new","curve41417::fe","",8],[10,"zero","","",8],[10,"one","","",8],[10,"get","","",8],[10,"get_mut","","",8],[10,"unpack","","",8],[10,"pack","","",8],[10,"len","","",8],[10,"cswap","","",8],[10,"carry","","",8],[10,"reduce","","",8],[10,"reduce_weak_from_bytes","","",8],[10,"parity_bit","","",8],[10,"muli","","",8],[10,"square","","",8],[10,"inv","","",8],[10,"pow4139","","",8],[10,"pow4125","","",8],[10,"pow4124","","",8],[10,"clone","","",8],[10,"clone_from","","",8],[10,"index","","",8],[10,"index_mut","","",8],[10,"add","","",8],[10,"sub","","",8],[10,"neg","","",8],[10,"mul","","",8],[10,"default","","",8],[10,"fmt","","",8],[10,"to_hex","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"assert_receiver_is_total_eq","","",8],[10,"new","curve41417::ed","Return a new group element with all its coordinates set to zero.",9],[10,"zero","","Return a group element with all its coordinates set to zero.",9],[10,"neutral","","Return the neutral point.",9],[10,"base","","Return the base point `(x, 34)` of prime order `L`.",9],[10,"unpack","","Unpack a Curve41417 point in Edwards representation from its\n`bytes` representation. `bytes` must hold a packed point wrapped\nin `EdPoint`, usually a previous result obtained from `pack()`.",9],[10,"pack","","Pack a group elem's coordinate `y` along with a sign bit taken from\nits `x` coordinate. This packed point may later be unpacked with\n`unpack()`.",9],[10,"scalar_mult","","Return a point `q` such that `q=n.self` where `n` is the scalar\nvalue applied to the point `self`. Note that the value of `n` is\nnot clamped by this method before the scalar multiplication is\naccomplished. Especially no cofactor multiplication is implicitly\napplied. Use `scalar_mult_cofactor()` prior to calling this method\nto explictly pre-cofactor this point.",9],[10,"scalar_mult_cofactor","","Return a point `q` such that `q=8.self` where `8` is curve's cofactor\napplied to this point's instance.",9],[10,"scalar_mult_base","","Return point `q` such that `q=n.BP` where `n` is a scalar value applied\nto the base point `BP`. Note that `n` is not clamped by this method\nbefore the multiplication. Calling this method is equivalent to calling\n`GroupElem::base().scalar_mult(&n)`.",9],[10,"double_scalar_mult","","Return point `q` such that `q=n1.p1+n2.p2` where `n1` and `n2` are\nscalar values and `p1` and `p2` are group elements. Note that the\nvalues of `n1` and `n2` are not clamped by this method before their\nmultiplications.",9],[10,"keypair","","Generate keypair `(pk, sk)` such that `pk=sk.BP` with secret scalar\n`sk` appropriately clamped and `pk` is the resulting public key.",9],[10,"to_mont","","Convert this point Edwards coordinates to Montgomery's\nx-coordinate. This result may be used as input point in\n`curve41417::mont` scalar multiplications.",9],[10,"elligator_to_representation","","Use [Elligator](http://elligator.cr.yp.to/) to encode a curve\npoint to a byte-string representation.",9],[10,"elligator_from_representation","","Map a byte-string representation to a curve point. Return a valid\ngroup element if it produces to a well-defined point.",9],[10,"elligator_from_bytes","","Map a byte-string to a curve point. Return a valid group element\nif `s` produces to a well-defined point. The provided input is\nfirst reduced in `Fq`. For better uniformity of the distribution\nin `Fq` the input must be sufficiently large.",9],[10,"add","","Add points.",9],[10,"sub","","Subtract points.",9],[10,"neg","","Negate point.",9],[10,"mul","","Multiply point `self` with scalar value `other`. Note that\ncurrently it is not possible to symmetrically overload the `*`\noperator of a scalar value to support `scalar * point` when\n`point` is a `GroupElem`.",9],[10,"drop","","Before being released point's coordinates are zeroed-out.",9],[10,"clone","","",9],[10,"clone_from","","",9],[10,"default","","By default return the neutral point.",9],[10,"fmt","","Format as hex-string.",9],[10,"to_hex","","",9],[10,"eq","","Constant-time points equality comparison.",9],[10,"ne","","",9],[10,"assert_receiver_is_total_eq","","",9],[10,"new_rand","curve41417::sc","Generate a new random `ScalarElem` between `[0, L-1]`.\nUse `urandom` as PRNG.",10],[10,"zero","","Return scalar value representing `0`.",10],[10,"len","","",10],[10,"unpack","","Unpack scalar value `n`. It must represent a value strictly in\n`[0, L-1]` and it should not be expected to be reduced on unpacking.",10],[10,"unpack_from_bytes","","Unpack bytes `b` as a scalar and reduce it `mod L`. Note that `B832`\ninstances might provide a better uniformity of distribution on\nreductions `mod L`.",10],[10,"pack","","Pack the current scalar value reduced `mod L`. It is not until\nthis method is called that the scalar element is reduced to its\ncanonical form.",10],[10,"reduce_from_bytes","","Unpack bytes `b` as a scalar, reduce it `mod L` and return the packed\nreduced result.",10],[10,"is_zero","","Check if `self` is equal to `0`.",10],[10,"clone","","",10],[10,"clone_from","","",10],[10,"index","","",10],[10,"index_mut","","",10],[10,"add","","Add scalars.",10],[10,"sub","","Substract scalars.",10],[10,"neg","","Negate scalar.",10],[10,"mul","","Multiply scalars.",10],[10,"from_i64","","",10],[10,"from_u64","","",10],[10,"from_int","","",10],[10,"from_i8","","",10],[10,"from_i16","","",10],[10,"from_i32","","",10],[10,"from_uint","","",10],[10,"from_u8","","",10],[10,"from_u16","","",10],[10,"from_u32","","",10],[10,"from_f32","","",10],[10,"from_f64","","",10],[10,"default","","Return the scalar value 0 as default.",10],[10,"rand","","Generate a random `ScalarElem` between `[0, L-1]`, and its value\nis not clamped. Be sure to use a secure PRNG when calling this\nmethod. For instance `ScalarElem::new_rand()` uses urandom.",10],[10,"fmt","","Format as hex-string.",10],[10,"to_hex","","",10],[10,"assert_receiver_is_total_eq","","",10],[10,"eq","","Constant-time equality comparison.",10],[10,"ne","","",10],[10,"new","common::sbuf","",11],[10,"allocate","","",11],[10,"deallocate","","",11],[10,"new","","",12],[10,"allocate","","",12],[10,"deallocate","","",12],[10,"len","","",13],[10,"new_zero","","New allocated buffer with its memory zeroed-out.",13],[10,"new_rand","","New allocated buffer with its memory randomly generated.",13],[10,"from_fn","","New allocated buffer with its `length` elements initialized from\nprovided closure `op`.",13],[10,"from_slice","","New buffer from slice.",13],[10,"from_buf","","New buffer from unsafe buffer.",13],[10,"from_slices","","Build a new instance by concatenating `items` together.",13],[10,"from_sbufs","","Build a new instance by concatenating `items` together.",13],[10,"as_ptr","","Return an immutable pointer to buffer's memory.",13],[10,"as_mut_ptr","","Return a mutable pointer to buffer's memory.",13],[10,"as_slice","","Work with `self` as a slice.",13],[10,"as_mut_slice","","Work with `self` as a mutable slice.",13],[10,"as_cast","","Cast `self` with another type and return a slice on it.",13],[10,"as_mut_cast","","Cast `self` with another type and return a mut slice on it.",13],[10,"get","","Return a reference to the value at index `index`. Fails if\n`index` is out of bounds.",13],[10,"get_mut","","Return a mutable reference to the value at index `index`. Fails\nif `index` is out of bounds.",13],[10,"iter","","Return an iterator over references to the elements of the buffer\nin order.",13],[10,"iter_mut","","Return an iterator over mutable references to the elements of the\nbuffer in order.",13],[10,"slice","","Return a slice of self spanning the interval [`start`, `end`).\nFails when the slice (or part of it) is outside the bounds of self,\nor when `start` > `end`.",13],[10,"slice_mut","","Return a mutable slice of `self` between `start` and `end`.\nFails when `start` or `end` point outside the bounds of `self`, or when\n`start` > `end`.",13],[10,"slice_from","","Return a slice of `self` from `start` to the end of the buffer.\nFails when `start` points outside the bounds of self.",13],[10,"slice_from_mut","","Return a mutable slice of self from `start` to the end of the buffer.\nFails when `start` points outside the bounds of self.",13],[10,"slice_to","","Return a slice of self from the start of the buffer to `end`.\nFails when `end` points outside the bounds of self.",13],[10,"slice_to_mut","","Return a mutable slice of self from the start of the buffer to `end`.\nFails when `end` points outside the bounds of self.",13],[10,"split_at_mut","","Return a pair of mutable slices that divides the buffer at an index.",13],[10,"reverse","","Reverse the order of elements in a buffer, in place.",13],[10,"from_bytes","","New buffer from bytes.",13],[10,"drop","","",13],[10,"clone","","",13],[10,"clone_from","","",13],[10,"index","","",13],[10,"index_mut","","",13],[10,"as_slice_","","",13],[10,"slice_from_or_fail","","",13],[10,"slice_to_or_fail","","",13],[10,"slice_or_fail","","",13],[10,"as_mut_slice_","","",13],[10,"slice_from_or_fail_mut","","",13],[10,"slice_to_or_fail_mut","","",13],[10,"slice_or_fail_mut","","",13],[10,"deref","","",13],[10,"deref_mut","","",13],[10,"eq","","",13],[10,"ne","","",13],[10,"assert_receiver_is_total_eq","","",13],[10,"fmt","","",13],[10,"encode","","",13],[10,"decode","","",13],[10,"to_hex","","",13],[1,"B416","crypto::curve41417::bytes","52-bytes container."],[1,"B512","","64-bytes container."],[1,"B832","","104-bytes container."],[6,"Reducible","","Tag `Bytes` containers deemed sufficiently large for providing a good\nuniformity of the distribution when reduced `mod L` (base point's order).\nSee [this](http://ed25519.cr.yp.to/ed25519-20110926.pdf) rationale\npresented in section 2."],[1,"Scalar","","Wrapper around `B416` packed value used in crypto ops."],[1,"MontPoint","","Wrapper around `B416` packed value used in crypto ops."],[1,"EdPoint","","Wrapper around `B416` packed value used in crypto ops."],[1,"Elligator","","Wrapper around `B416` packed value used in crypto ops."],[0,"ed","crypto::curve41417","Edwards-form Curve41417 representation"],[1,"GroupElem","crypto::curve41417::ed","A group element i.e. a point in Edwards representation."],[0,"mont","crypto::curve41417","Montgomery-form Curve41417 representation"],[3,"scalar_mult","crypto::curve41417::mont","Compute scalar multiplication"],[3,"scalar_mult_base","","Compute scalar multiplication with base point"],[3,"keypair","","Generate a new key pair"],[0,"sc","crypto::curve41417","Curve41417 scalar operations"],[1,"ScalarElem","crypto::curve41417::sc","Scalar element used in scalar operations."],[0,"encrypt","crypto","Encrypt traits"],[6,"Encrypt","crypto::encrypt","Trait for encryptable types"],[9,"encrypt","","Use the current key stream state provided by `stream` to encrypt the\nvalue of `Self` and put the result in `output`. `output` must be equal\nor larger in size to the size of the value submitted for encryption\nby `Self`.",14],[10,"decrypt","","Decrypt operation. See encrypt.",14],[6,"CipherEncrypt","","Trait for ciphers implementing encrypt/decrypt operations"],[9,"encrypt","","Encrypt `input` and put the result in `output`. The size of\n`output` must at least be of the size of `input` or more\ndepending on the underlying mode of operations used. Return the\nnumber of encrypted bytes written in `output` or `Err` on error.",15],[10,"decrypt","","Decrypt `input` and put the result in `output`. The size of\n`output` must at least be of the size of `input`. Return the\nnumber of decrypted bytes written in `output` or `Err` on error.",15],[6,"Encrypter","","Encrypter"],[9,"encrypt","","Encrypt the encryptable `value` and put the result in `output`.\nThe size of `output` must at least be of the size of `input`.\nReturn the number of encrypted bytes written to `output`.",16],[10,"decrypt","","Decrypt `value` in `output`. See encrypt operation.",16],[10,"encrypt","collections::string","",17],[10,"encrypt","collections::vec","",18],[10,"encrypt","rustrt::c_str","",19],[0,"hash","crypto","Hash traits"],[6,"Hash","crypto::hash","Trait for hashable types"],[9,"hash","","",20],[6,"Hasher","","Hasher"],[9,"hash","","Hash `input` and put the result in `output`. Return the number of bytes\nwritten to `output`.",21],[6,"Authenticator","","Authenticator"],[9,"authenticate","","Authenticate `input` with `key` and put the result in `output`.\nReturn the number of bytes written to `output`.",22],[10,"hash","collections::string","",17],[10,"hash","collections::vec","",18],[10,"hash","rustrt::c_str","",19],[10,"hash","common::sbuf","",13],[10,"hash","crypto::curve41417::bytes","",1],[10,"hash","","",2],[10,"hash","","",3],[10,"hash","","",4],[10,"hash","","",5],[10,"hash","","",6],[0,"chacha20","crypto","[Chacha20](http://cr.yp.to/chacha.html) stream cipher"],[1,"ChachaStream","crypto::chacha20","Chacha20 key stream generator"],[1,"ChachaEncrypter","","Chacha20 Encrypter"],[1,"ChachaAead","","[Chacha20-Poly1305 AEAD](http://tools.ietf.org/html/draft-irtf-cfrg-chacha20-poly1305-01)"],[3,"encrypt","","Encrypt bytes"],[3,"decrypt","","Decrypt bytes"],[18,"KEY_SIZE","",""],[18,"NONCE_SIZE","",""],[18,"NONCE_AEAD_SIZE","",""],[18,"BLOCK_SIZE","",""],[10,"new","","Return a new `ChachaStream` instance. `key` is the secret key of\nsize `KEY_SIZE` and `nonce` is the nonce of size `NONCE_SIZE`.",23],[10,"read_bytes_ref","","Read by reference up to count bytes. Return `Err` on end-of-stream.",23],[10,"read_byte_ref","","Read by reference a single byte. Return `Err` on end-of-stream.",23],[10,"encrypt_to_sbuf","","Convenience method directly returning the encrypted data as a\n`SBuf`buffer.",23],[10,"decrypt_to_sbuf","","",23],[10,"skip","","Read and discard the next `n` keystream bytes. Return the\nnumber of bytes discarded.",23],[10,"encrypt","","",23],[10,"fill_buf","","",23],[10,"consume","","",23],[10,"read","","",23],[10,"clone","","",23],[10,"new","","New encrypter instance from `key` and `nonce`.",24],[10,"new_with_stream","","New encrypter instance from already instanciated Chacha20 key stream.",24],[10,"encrypt","","Encrypt `value`. Internally for a same instance, the encryption\nstate is maintained between repeated calls to this method or to the\ndecrypt method.",24],[10,"new","","Return a new `ChachaAead` instance. `key` is the secret key of\nsize `KEY_SIZE`.",25],[10,"seal","","`nonce` is a unique nonce of size `NONCE_AEAD_SIZE`, `plaintext`\nis the data to encrypt and authenticate. `aad` is some optional\nadditional data to authenticate. The authenticated ciphertext\nis returned on output.",25],[10,"open","","`nonce` is a unique nonce of size `NONCE_AEAD_SIZE`, `ciphertext`\nis the authenticated and encypted data to decrypt. `aad` is some\noptional additional data authenticated with the ciphertext. This\nmethod returns the plaintext on output.",25],[10,"clone","","",25],[0,"poly1305","crypto","[Poly1305](http://cr.yp.to/mac.html) one-time authenticator"],[1,"Poly1305","crypto::poly1305","Poly1305 one-time authenticator"],[1,"Poly1305Authenticator","","Poly1305 Authenticator"],[3,"authenticate","","All-in-one Poly1305 one-time mac function"],[18,"KEY_SIZE","",""],[18,"TAG_SIZE","",""],[10,"new","","",26],[10,"tag","","Write the authenticator value to `output`which must be of size\n`TAG_SIZE`. Return `TAG_SIZE`.",26],[10,"tag_to_sbuf","","Convenience method returning the authenticator value in a `SBuf`\nbuffer.",26],[10,"write","","",26],[10,"clone","","",26],[10,"authenticate","","",27],[0,"sha3","crypto","SHA-3 hash as specified in the\n[FIPS 202 draft](http://csrc.nist.gov/publications/drafts/fips-202/fips_202_draft.pdf)"],[1,"Sha3","crypto::sha3","SHA-3 State."],[1,"Sha3Hasher","","SHA-3 Hasher."],[2,"Sha3Mode","","SHA-3 Modes."],[12,"Sha3_224","","",28],[12,"Sha3_256","","",28],[12,"Sha3_384","","",28],[12,"Sha3_512","","",28],[12,"Shake128","","",28],[12,"Shake256","","",28],[3,"hash","","All-in-one SHA-3 hash function"],[10,"digest_length","","Return the expected hash size in bytes specified for `mode`, or 0\nfor modes with variable output as for shake functions.",28],[10,"is_shake","","Return `true` if `mode` is a SHAKE mode.",28],[10,"new","","New SHA-3 instanciated from specified SHA-3 `mode`.",29],[10,"sha3_224","","New SHA3-224 instance.",29],[10,"sha3_256","","New SHA3-256 instance.",29],[10,"sha3_384","","New SHA3-384 instance.",29],[10,"sha3_512","","New SHA3-512 instance.",29],[10,"shake_128","","New SHAKE-128 instance.",29],[10,"shake_256","","New SHAKE-256 instance.",29],[10,"digest_length","","Return the expected hash size in bytes specified for `mode`, or 0\nfor modes with variable output as for shake functions.",29],[10,"skip","","Read and discard the next `n` squeezed bytes. Return the\nnumber of bytes discarded.",29],[10,"write","","",29],[10,"read","","",29],[10,"clone","","",29],[10,"new","","New `Sha3Hasher` instance initialized from SHA-3 function defined by\n`mode`.",30],[10,"hash","","",30],[0,"kdf","crypto","Key Derivation Function"],[1,"XKdf","crypto::kdf","[XKdf](http://csrc.nist.gov/groups/ST/hash/sha-3/Aug2014/documents/perlner_kmac.pdf)\nkey derivation function based on SHA3-SHAKE and\n[NIST-SP800-108](http://csrc.nist.gov/publications/nistpubs/800-108/sp800-108.pdf)"],[10,"new","","`mode` is the SHAKE mode, `key` a key used as input, `label` identifies\nthe purpose for the derived keying material, `context` contains\ninformation related to the derived keying material and `size` specifies\nthe length in bytes of the derived keying material.",31],[10,"skip","","Read and discard the next `n` key derived bytes. Return the\nnumber of bytes discarded.",31],[10,"derived_key","","Return the derived key all-in-one read.",31],[10,"read","","Read key derived bytes to `buf` and return the number of bytes\nread.",31],[10,"clone","","",31],[0,"noise","crypto","[Noise](https://github.com/trevp/noise/blob/master/noise.md) crypto\nprotocols"],[1,"Noise414","crypto::noise","Noise414 cipher suite"],[1,"Blob","","Noise Blob"],[1,"Box","","Noise Box"],[6,"NoiseSuite","","Noise cipher suite"],[9,"new","","Return a new instance of this cipher suite.",32],[9,"name","","Cipher suite's name.",32],[9,"keypair","","Generate and return a new pair of keys (pubkey, privkey).",32],[9,"dh","","Return the point resulting from the DH computation.",32],[9,"kdf","","Derive a secret key from `secret`, `extra_secret`, `info` and\nwrite it in `output`, use all its length.",32],[9,"encrypt","","Encrypt `plaintext`, authenticate its result along with `authtext`.\nUpdate its context `key` and `nonce` and eventually return the\nciphertext. When `None` is returned `key` and `nonce` are not updated.\n`pad_len` should be `None` when no padding should be appended.",32],[9,"decrypt","","Authenticate `authtext` and the encrypted data `cyphertext`, then\ndecrypt `ciphertext`, update `key` and `nonce` and eventually\nreturn its plaintext. When `None` is returned `key` and `nonce`\nare not updated. `pad` is `true` when some padding was appended\nto the plaintext and must be removed, the plaintext is returned\nwithout padding. If the authentication failed `None` is returned.",32],[9,"cv_size","","Chaining variable's size.",32],[9,"cc_size","","Cipher context's size (key + mac).",32],[9,"key_size","","Cipher key's size.",32],[9,"nonce_size","","Cipher nonce's size.",32],[9,"dh_size","","DH keys size.",32],[9,"mac_size","","MAC tag's size.",32],[10,"new","","",33],[10,"name","","",33],[10,"keypair","","",33],[10,"dh","","",33],[10,"kdf","","",33],[10,"encrypt","","",33],[10,"decrypt","","",33],[10,"cv_size","","",33],[10,"cc_size","","",33],[10,"key_size","","",33],[10,"nonce_size","","",33],[10,"dh_size","","",33],[10,"mac_size","","",33],[10,"clone","","",33],[10,"new","","After instanciating a new instance `set_context()` must be called.",34],[10,"cipher_suite","","Return the underlying cipher suite used for crypto operations.",34],[10,"set_context","","Set crypto context, must be called before calling `seal()` or\n`open()`.",34],[10,"get_context","","Return current's crypto context `(key, nonce)`.",34],[10,"seal","","",34],[10,"open","","",34],[10,"clone","","",34],[10,"new","","",35],[10,"cipher_suite","","Return the underlying cipher suite used for crypto operations.",35],[10,"keypair","","Generate a new key pair.",35],[10,"seal","","Box `contents` and return the tuple `(boxed_data, cv)` where\n`cv` is the resulting chaining variable.",35],[10,"open","","Unbox `box_data` and return the tuple `(sender_pubkey, contents, cv)`.\nWhere `sender_pubkey` is the non-ephemeral sender's public key to\nwhich `box_data` was encrypted to. `contents` is the decrypted data\nand `cv` is the resulting chaining variable. `recvr_privkey` is\nusually an ephemeral key.",35],[10,"clone","","",35],[0,"eke","crypto","Encrypted Key Exchange"],[1,"Eke","crypto::eke","Encrypted key exchange"],[2,"Role","","Peer's role"],[12,"Client","","",36],[12,"Server","","",36],[10,"new","","Create a new `Eke` instance with defined caller's `role`.\n`client_info` and `server_info` are additional infos to be\nhashed in the confirmation messages and in the final session\nkey. `secret` is the shared secret between both peers.",37],[10,"is_done","","Return `true` if the final state of the protocol is reached, in which\ncase `get_msg()` and `process_msg()` must not be called afterward.",37],[10,"is_success","","Return `true` if the final state is reached on a success.",37],[10,"get_msg","","Return the protocol message corresponding to the current state, or\nan irrecoverable error on error. The resulting message is expected\nto be the input message argument of `process_msg()` usually called\nfrom another peer.",37],[10,"process_msg","","Process a message `msg` obtained from `get_msg()` usually called from\nanother peer; otherwise return an irrecoverable error on error.",37],[10,"session_key","","Return the final session key shared by both peers or an error\nif the protocol is not in the final state or has failed in a\nprevious step.",37],[10,"clone","","",37],[0,"sbuf","crypto","Secure Buffer"],[6,"Allocator","crypto::sbuf","Trait for allocators."],[9,"new","","",38],[9,"allocate","","",38],[9,"deallocate","","",38],[4,"DefaultAllocator","",""],[1,"StdHeapAllocator","","Standard heap allocator, use Rust's allocator (currently jemalloc),\ndoes not implement guarded pages."],[1,"GuardedHeapAllocator","","Guarded heap allocator, add a guarded page before and after\neach allocated buffer."],[1,"SBuf","","Secure Buffer."],[0,"utils","crypto","Crypto utils"],[3,"u8to32_le","crypto::utils","`Bytes` to `u32` little-endian decoding."],[3,"u32to8_le","","`u32` to `bytes` little-endian encoding."],[3,"u8to64_le","","`Bytes` to `u64` little-endian decoding."],[3,"u64to8_le","","`u64` to `bytes` little-endian encoding."],[3,"pad16","","Pad to multiple of 16."],[3,"zero_memory","","Zero-out memory buffer."],[3,"copy_slice_memory","","Copy memory buffer."],[3,"bytes_eq","","Compare bytes buffers."],[3,"bytes_cswap","","Conditionally swap bytes."],[3,"urandom_rng","","Instanciate a secure RNG based on `urandom`."]],"paths":[[6,"Bytes"],[1,"B416"],[1,"B512"],[1,"B832"],[1,"Scalar"],[1,"MontPoint"],[1,"EdPoint"],[1,"Elligator"],[1,"FieldElem"],[1,"GroupElem"],[1,"ScalarElem"],[1,"StdHeapAllocator"],[1,"GuardedHeapAllocator"],[1,"SBuf"],[6,"Encrypt"],[6,"CipherEncrypt"],[6,"Encrypter"],[1,"String"],[1,"Vec"],[1,"CString"],[6,"Hash"],[6,"Hasher"],[6,"Authenticator"],[1,"ChachaStream"],[1,"ChachaEncrypter"],[1,"ChachaAead"],[1,"Poly1305"],[1,"Poly1305Authenticator"],[2,"Sha3Mode"],[1,"Sha3"],[1,"Sha3Hasher"],[1,"XKdf"],[6,"NoiseSuite"],[1,"Noise414"],[1,"Blob"],[1,"Box"],[2,"Role"],[1,"Eke"],[6,"Allocator"]]};
initSearch(searchIndex);
